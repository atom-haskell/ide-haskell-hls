"use strict";
const atom_languageclient_1 = require("atom-languageclient");
const adapters_1 = require("./adapters");
class HLSLanguageClient extends atom_languageclient_1.AutoLanguageClient {
    constructor() {
        super(...arguments);
        this.renderer = { render: null };
    }
    getGrammarScopes() {
        return ['source.haskell'];
    }
    getLanguageName() {
        return 'Haskell';
    }
    getServerName() {
        return 'haskell-language-server';
    }
    startServerProcess(projectPath) {
        return super.spawn('haskell-language-server-wrapper', ['--lsp'], {
            cwd: projectPath,
        });
    }
    consumeMarkdownRenderer(renderer) {
        this.renderer.render = renderer.render;
    }
    consumeUPI(service) {
        this.upi = service({
            name: 'hls',
            actions: async (editor, range, _type) => {
                const acts = await this.getCodeActions(editor, range, []);
                if (!acts)
                    return undefined;
                return Promise.all(acts.map(async (x) => ({
                    title: await x.getTitle(),
                    apply: () => x.apply(),
                })));
            },
        });
        this.consumeLinterV2(adapters_1.linterAdapter(this.upi, this.provideCodeActions()));
        this.consumeDatatip(adapters_1.datatipAdapter(service, this.upi, this.renderer));
        return this.upi;
    }
    async getDatatip(editor, point) {
        const datatip = await super.getDatatip(editor, point);
        if (datatip) {
            if ('component' in datatip) {
                return datatip;
            }
            else {
                datatip.markedStrings = datatip.markedStrings.filter((x) => x.value);
                if (datatip.markedStrings.length > 0) {
                    return datatip;
                }
            }
        }
        return null;
    }
}
module.exports = new HLSLanguageClient();
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibWFpbi5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uL3NyYy9tYWluLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQSw2REFBd0Q7QUFHeEQseUNBQTBEO0FBRzFELE1BQU0saUJBQWtCLFNBQVEsd0NBQWtCO0lBQWxEOztRQUVVLGFBQVEsR0FBRyxFQUFFLE1BQU0sRUFBRSxJQUF3QyxFQUFFLENBQUE7SUF1RHpFLENBQUM7SUF0REMsZ0JBQWdCO1FBQ2QsT0FBTyxDQUFDLGdCQUFnQixDQUFDLENBQUE7SUFDM0IsQ0FBQztJQUNELGVBQWU7UUFDYixPQUFPLFNBQVMsQ0FBQTtJQUNsQixDQUFDO0lBQ0QsYUFBYTtRQUNYLE9BQU8seUJBQXlCLENBQUE7SUFDbEMsQ0FBQztJQUVELGtCQUFrQixDQUFDLFdBQWdCO1FBQ2pDLE9BQU8sS0FBSyxDQUFDLEtBQUssQ0FBQyxpQ0FBaUMsRUFBRSxDQUFDLE9BQU8sQ0FBQyxFQUFFO1lBQy9ELEdBQUcsRUFBRSxXQUFXO1NBQ2pCLENBQUMsQ0FBQTtJQUNKLENBQUM7SUFFRCx1QkFBdUIsQ0FBQyxRQUF5QjtRQUMvQyxJQUFJLENBQUMsUUFBUSxDQUFDLE1BQU0sR0FBRyxRQUFRLENBQUMsTUFBTSxDQUFBO0lBQ3hDLENBQUM7SUFFRCxVQUFVLENBQUMsT0FBNkI7UUFDdEMsSUFBSSxDQUFDLEdBQUcsR0FBRyxPQUFPLENBQUM7WUFDakIsSUFBSSxFQUFFLEtBQUs7WUFDWCxPQUFPLEVBQUUsS0FBSyxFQUFFLE1BQU0sRUFBRSxLQUFLLEVBQUUsS0FBSyxFQUFFLEVBQUU7Z0JBQ3RDLE1BQU0sSUFBSSxHQUFHLE1BQU0sSUFBSSxDQUFDLGNBQWMsQ0FBQyxNQUFNLEVBQUUsS0FBSyxFQUFFLEVBQUUsQ0FBQyxDQUFBO2dCQUN6RCxJQUFJLENBQUMsSUFBSTtvQkFBRSxPQUFPLFNBQVMsQ0FBQTtnQkFDM0IsT0FBTyxPQUFPLENBQUMsR0FBRyxDQUNoQixJQUFJLENBQUMsR0FBRyxDQUFDLEtBQUssRUFBRSxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUM7b0JBQ3JCLEtBQUssRUFBRSxNQUFNLENBQUMsQ0FBQyxRQUFRLEVBQUU7b0JBQ3pCLEtBQUssRUFBRSxHQUFHLEVBQUUsQ0FBQyxDQUFDLENBQUMsS0FBSyxFQUFFO2lCQUN2QixDQUFDLENBQUMsQ0FDSixDQUFBO1lBQ0gsQ0FBQztTQUNGLENBQUMsQ0FBQTtRQUNGLElBQUksQ0FBQyxlQUFlLENBQUMsd0JBQWEsQ0FBQyxJQUFJLENBQUMsR0FBRyxFQUFFLElBQUksQ0FBQyxrQkFBa0IsRUFBRSxDQUFDLENBQUMsQ0FBQTtRQUN4RSxJQUFJLENBQUMsY0FBYyxDQUFDLHlCQUFjLENBQUMsT0FBTyxFQUFFLElBQUksQ0FBQyxHQUFHLEVBQUUsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUE7UUFDckUsT0FBTyxJQUFJLENBQUMsR0FBRyxDQUFBO0lBQ2pCLENBQUM7SUFFRCxLQUFLLENBQUMsVUFBVSxDQUFDLE1BQWtCLEVBQUUsS0FBWTtRQUUvQyxNQUFNLE9BQU8sR0FBRyxNQUFNLEtBQUssQ0FBQyxVQUFVLENBQUMsTUFBTSxFQUFFLEtBQUssQ0FBQyxDQUFBO1FBQ3JELElBQUksT0FBTyxFQUFFO1lBQ1gsSUFBSSxXQUFXLElBQUksT0FBTyxFQUFFO2dCQUMxQixPQUFPLE9BQU8sQ0FBQTthQUNmO2lCQUFNO2dCQUNMLE9BQU8sQ0FBQyxhQUFhLEdBQUcsT0FBTyxDQUFDLGFBQWEsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQTtnQkFDcEUsSUFBSSxPQUFPLENBQUMsYUFBYSxDQUFDLE1BQU0sR0FBRyxDQUFDLEVBQUU7b0JBQ3BDLE9BQU8sT0FBTyxDQUFBO2lCQUNmO2FBQ0Y7U0FDRjtRQUNELE9BQU8sSUFBSSxDQUFBO0lBQ2IsQ0FBQztDQUNGO0FBRUQsaUJBQVMsSUFBSSxpQkFBaUIsRUFBRSxDQUFBIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQXV0b0xhbmd1YWdlQ2xpZW50IH0gZnJvbSAnYXRvbS1sYW5ndWFnZWNsaWVudCdcbmltcG9ydCB7IFRleHRFZGl0b3IsIFBvaW50IH0gZnJvbSAnYXRvbSdcbmltcG9ydCAqIGFzIFVQSSBmcm9tICdhdG9tLWhhc2tlbGwtdXBpJ1xuaW1wb3J0IHsgZGF0YXRpcEFkYXB0ZXIsIGxpbnRlckFkYXB0ZXIgfSBmcm9tICcuL2FkYXB0ZXJzJ1xuaW1wb3J0IHR5cGUgeyBNYXJrZG93blNlcnZpY2UgfSBmcm9tICdhdG9tLWlkZS1iYXNlJ1xuXG5jbGFzcyBITFNMYW5ndWFnZUNsaWVudCBleHRlbmRzIEF1dG9MYW5ndWFnZUNsaWVudCB7XG4gIHByaXZhdGUgdXBpPzogVVBJLklVUElJbnN0YW5jZVxuICBwcml2YXRlIHJlbmRlcmVyID0geyByZW5kZXI6IG51bGwgYXMgTWFya2Rvd25TZXJ2aWNlWydyZW5kZXInXSB8IG51bGwgfVxuICBnZXRHcmFtbWFyU2NvcGVzKCkge1xuICAgIHJldHVybiBbJ3NvdXJjZS5oYXNrZWxsJ11cbiAgfVxuICBnZXRMYW5ndWFnZU5hbWUoKSB7XG4gICAgcmV0dXJuICdIYXNrZWxsJ1xuICB9XG4gIGdldFNlcnZlck5hbWUoKSB7XG4gICAgcmV0dXJuICdoYXNrZWxsLWxhbmd1YWdlLXNlcnZlcidcbiAgfVxuXG4gIHN0YXJ0U2VydmVyUHJvY2Vzcyhwcm9qZWN0UGF0aDogYW55KSB7XG4gICAgcmV0dXJuIHN1cGVyLnNwYXduKCdoYXNrZWxsLWxhbmd1YWdlLXNlcnZlci13cmFwcGVyJywgWyctLWxzcCddLCB7XG4gICAgICBjd2Q6IHByb2plY3RQYXRoLFxuICAgIH0pXG4gIH1cblxuICBjb25zdW1lTWFya2Rvd25SZW5kZXJlcihyZW5kZXJlcjogTWFya2Rvd25TZXJ2aWNlKSB7XG4gICAgdGhpcy5yZW5kZXJlci5yZW5kZXIgPSByZW5kZXJlci5yZW5kZXJcbiAgfVxuXG4gIGNvbnN1bWVVUEkoc2VydmljZTogVVBJLklVUElSZWdpc3RyYXRpb24pIHtcbiAgICB0aGlzLnVwaSA9IHNlcnZpY2Uoe1xuICAgICAgbmFtZTogJ2hscycsXG4gICAgICBhY3Rpb25zOiBhc3luYyAoZWRpdG9yLCByYW5nZSwgX3R5cGUpID0+IHtcbiAgICAgICAgY29uc3QgYWN0cyA9IGF3YWl0IHRoaXMuZ2V0Q29kZUFjdGlvbnMoZWRpdG9yLCByYW5nZSwgW10pXG4gICAgICAgIGlmICghYWN0cykgcmV0dXJuIHVuZGVmaW5lZFxuICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwoXG4gICAgICAgICAgYWN0cy5tYXAoYXN5bmMgKHgpID0+ICh7XG4gICAgICAgICAgICB0aXRsZTogYXdhaXQgeC5nZXRUaXRsZSgpLFxuICAgICAgICAgICAgYXBwbHk6ICgpID0+IHguYXBwbHkoKSxcbiAgICAgICAgICB9KSksXG4gICAgICAgIClcbiAgICAgIH0sXG4gICAgfSlcbiAgICB0aGlzLmNvbnN1bWVMaW50ZXJWMihsaW50ZXJBZGFwdGVyKHRoaXMudXBpLCB0aGlzLnByb3ZpZGVDb2RlQWN0aW9ucygpKSlcbiAgICB0aGlzLmNvbnN1bWVEYXRhdGlwKGRhdGF0aXBBZGFwdGVyKHNlcnZpY2UsIHRoaXMudXBpLCB0aGlzLnJlbmRlcmVyKSlcbiAgICByZXR1cm4gdGhpcy51cGlcbiAgfVxuICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vIG92ZXJyaWRlcyAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4gIGFzeW5jIGdldERhdGF0aXAoZWRpdG9yOiBUZXh0RWRpdG9yLCBwb2ludDogUG9pbnQpIHtcbiAgICAvLyBITFMgbGlrZXMgdG8gcmV0dXJuIGVtcHR5IGRhdGF0aXBzOyB0aGlzIHRyaWVzIHRvIGZpbHRlciB0aG9zZSBvdXRcbiAgICBjb25zdCBkYXRhdGlwID0gYXdhaXQgc3VwZXIuZ2V0RGF0YXRpcChlZGl0b3IsIHBvaW50KVxuICAgIGlmIChkYXRhdGlwKSB7XG4gICAgICBpZiAoJ2NvbXBvbmVudCcgaW4gZGF0YXRpcCkge1xuICAgICAgICByZXR1cm4gZGF0YXRpcFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGF0YXRpcC5tYXJrZWRTdHJpbmdzID0gZGF0YXRpcC5tYXJrZWRTdHJpbmdzLmZpbHRlcigoeCkgPT4geC52YWx1ZSlcbiAgICAgICAgaWYgKGRhdGF0aXAubWFya2VkU3RyaW5ncy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgcmV0dXJuIGRhdGF0aXBcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbFxuICB9XG59XG5cbmV4cG9ydCA9IG5ldyBITFNMYW5ndWFnZUNsaWVudCgpXG4iXX0=